using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    public MultiSpryt mSprite;
    public Spryt sStand;
    public Spryt sWalk;
    public Spryt sJump;
    public Spryt sFall;
    public Spryt sCrouch;
    public SSineData aJump;
    public SSineData aLand;
    public SSineData aGetUp;
    public float hSpeedFalloff = 0.8f;
    public float moveSpeed = 5f;
    public float jumpHeight = 16f;
    public bool canJump = true;
    public GameObject deadPrefab;

    private bool isCrouching = false;
    private Rigidbody2D myBody;
    private Vector2 startPosition;
    private AudioSource audioSource;

    private void OnEnable() {
//Subscribe to the Animation End Event generated by mSprite
        mSprite.OnAnimationEnd += Sprite_AnimationEnd;
    }
    private void OnDisable() {
//Unsubscribe from the Animation End Event generated by mSprite; important to avoid memory leaks!!
        mSprite.OnAnimationEnd -= Sprite_AnimationEnd;
    }

    private void Sprite_AnimationEnd(object sender, Spryt spryt) {
//Each Animation End event passes along the Spryt which was playing which you can compare against so unique things can occur depending on which Spryt ended
        if (spryt == sWalk) {
    //When the walk animation plays through, play a footstep sound
            audioSource.Play();
        }
    }

    private void Start() {
        startPosition = transform.position;
        myBody = GetComponent<Rigidbody2D>();
        audioSource = GetComponent<AudioSource>();
    }

    void Update() {
        Move();
        HandleAnimations();
    }

    public void Move() {
//Horizontal movement
        float hspeed = myBody.velocity.x;
        float vspeed = myBody.velocity.y;
        bool neitherKeyIsPressed = true;
        if (mSprite.Index != sCrouch) {
            if (Input.GetKey(KeyCode.A)) {
                hspeed = -moveSpeed;
                neitherKeyIsPressed = false;
            }
            if (Input.GetKey(KeyCode.D)) {
                hspeed = moveSpeed;
                neitherKeyIsPressed = false;
            }
        }
        if (neitherKeyIsPressed)
            hspeed *= hSpeedFalloff;
        myBody.velocity = new Vector2(hspeed, vspeed);
//Jumping
        if (canJump && Input.GetKeyDown(KeyCode.Space)) {
            Jump();
        }
    }

    public void HandleAnimations() {
        bool inAir = Mathf.Abs(myBody.velocity.y) > 0.01f; //Assuming if your vertical speed is close to zero, you aren't in the air
        if (inAir) {
            bool falling = myBody.velocity.y < Mathf.Epsilon; //If your vertical velocity is less than zero, you are falling
    //If inAir, set Sprite State to either Jumping or Falling
            mSprite.Index = falling ? sFall : sJump;
        } else {
            bool isRunning = Mathf.Abs(myBody.velocity.x) > hSpeedFalloff; //If the magnitude of your movement is above a small threshold, you are walking, not standing
            bool isCrouched = mSprite.Index == sCrouch;
            bool downHeld = Input.GetKey(KeyCode.S);
    //If not inAir, set Sprite State to either Walking, Standing, or Crouching
            if (isCrouched) {
                if (!downHeld) {
                    mSprite.Combo(sStand, aGetUp);
                }
            } else {
                if (downHeld) {
                    mSprite.Combo(sCrouch, aLand);
                } else {
                    mSprite.Index = isRunning ? sWalk : sStand;
                }
            }
        }
    //Handle Sprite scaling and speed
        float hSpeed = Mathf.Abs(myBody.velocity.x);
        if (hSpeed > 0.01f) {
            mSprite.xScale = Mathf.Abs(transform.localScale.x) * Mathf.Sign(myBody.velocity.x); //Set xScale to + / - depending on direction of movement
        }
    }

    private void Jump() {
        myBody.velocity += new Vector2(0f, jumpHeight); //Apply the velocity to the rigidbody
        canJump = false; //Disable the ability to jump
        mSprite.SineSetData(aJump, true); //Play the Sine effect for a jump
    }

    private void OnCollisionEnter2D(Collision2D collision) {
        var foundComponent = collision.gameObject.GetComponent<BoxCollider2D>();
        if (foundComponent) {
    //In this super-basic player controller script, we'll say ANYTHING with a Box-Collider counts as valid to recover the ability to jump
            canJump = true;
            mSprite.SineSetData(aLand, true);
        }
    }

    private void OnTriggerEnter2D(Collider2D collision) {
//The only Trigger in the Sample Scene is the Skull, which kills the player upon touching it
        Destroy(gameObject);
        Instantiate(deadPrefab, mSprite.transform.position, Quaternion.identity);
    }

    /// <summary>
    /// This method COULD be used by the Respawn button, but it isn't. Instead, the button destroys and replaces the player
    /// </summary>
    public void Respawn() {
        myBody.velocity = Vector2.zero;
        transform.position = startPosition;
        mSprite.ResetSprite();
    }
}